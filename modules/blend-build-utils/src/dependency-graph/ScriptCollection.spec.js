"use strict";

var $oop = window['blend-oop'],
    $buildUtils = window['blend-build-utils'];

describe("$buildUtils", function () {
  describe("ScriptCollection", function () {
    var ScriptCollection,
        scriptCollection,
        extractor;

    beforeAll(function () {
      ScriptCollection = $oop.createClass('test.$buildUtils.ScriptCollection.ScriptCollection')
      .blend($buildUtils.ScriptCollection)
      .build();
      ScriptCollection.__builder.forwards = {list: [], lookup: {}};
      extractor = $buildUtils.BlendSymbolExtractor.create();
    });

    describe("#getFilePathsVsExports()", function () {
      beforeEach(function () {
        scriptCollection = ScriptCollection.fromData({
          'foo.js': $buildUtils.Script.fromScriptBody(
              'Foo = $oop.createClass("Foo")'),
          'bar.js': $buildUtils.Script.fromScriptBody(
              'Bar = $oop.createClass("Bar").blend(Foo)')
        });
      });

      it("should resolve exported symbols", function () {
        var result = scriptCollection.getFilePathsVsExports(extractor);
        expect(result.data).toEqual({
          "foo.js": {
            "Foo": 1
          },
          "bar.js": {
            "Bar": 1
          }
        });
      });
    });

    describe("#getFilePathsVsImports()", function () {
      beforeEach(function () {
        scriptCollection = ScriptCollection.fromData({
          'foo.js': $buildUtils.Script.fromScriptBody(
              'Foo = $oop.createClass("Foo")'),
          'bar.js': $buildUtils.Script.fromScriptBody(
              'Bar = $oop.createClass("Bar").blend(Foo)')
        });
      });

      it("should resolve imported symbols", function () {
        var result = scriptCollection.getFilePathsVsImports(extractor);
        expect(result.data).toEqual({
          "bar.js": {
            "Foo": 1
          }
        });
      });
    });

    describe("#getDependencyOrder()", function () {
      beforeEach(function () {
        scriptCollection = ScriptCollection.fromData({
          //@formatter:off
          "src/utils/environment-utils.js": $buildUtils.Script.fromScriptBody("\"use strict\";$oop.copyProperties($utils, /** @lends $utils */{/** Detects whether we are running in a browser environment. @returns {boolean} */ isBrowser: function () {return typeof window === 'object';}, /** Detects whether we are running in a browser environment. @returns {boolean} */ isNode: function () {return typeof global === 'object';}});\n"),
          "src/utils/Equatable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @mixin $utils.Equatable */ $utils.Equatable = $oop.createClass('$utils.Equatable').define(/** @lends $utils.Equatable# */{/** Tells whether current instance equals to the specified instance. @param {$utils.Equatable|$oop.Class} instance @returns {boolean} */ equals: function (instance) {return instance && (/* must have value*/ this === instance || /* either same instance*/ this.__classId === instance.__classId);/* or shares class*/}}).build();\n"),
          "src/utils/Matchable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Describes a pattern that can be matched against static variables. @interface $utils.Matchable */ $utils.Matchable = $oop.createClass('$utils.Matchable').define(/** @lends $utils.Matchable# */{/** Determines whether specified instance matches current one. @param {...*} instance @returns {boolean} */ matches: function (instance) {}}).build();\n"),
          "src/string/string-utils.js": $buildUtils.Script.fromScriptBody("\"use strict\";$oop.copyProperties($utils, /** @lends $utils */{/** Pairs up character sets with escape regular expressions. @type {object} @constant @private */ _escapeRegexpLookup: {}, /** Pairs up character sets with un-escape regular expressions. @type {object} @constant @private */ _unescapeRegexpLookup: {}, /** Cached splitter regular expressions. @constant @private */ _splitterRegexpLookup: {}, /** Serializes variables. Returns strings unchanged, converts numbers and booleans to string, calls .toString() on Objects, returns empty string for undefined, null, and functions. @function $utils.stringify @param {*} [stringifiable] @returns {string} */ stringify: function (stringifiable) {switch (typeof stringifiable) {case 'string':return stringifiable;case 'object':return stringifiable instanceof Object ? stringifiable.toString() : '';case 'boolean':case 'number':return String(stringifiable);default:case 'function':case 'undefined':return '';}}, /** Escapes specified characters in specified string. @param {string} string @param {string} chars @returns {string} */ escape: function (string, chars) {var escapeRegexpLookup = $utils._escapeRegexpLookup, re = escapeRegexpLookup[chars];if (!re) {re = escapeRegexpLookup[chars] = new RegExp('\\\\\\\\|[' + chars + ']', 'g');}return string.replace(re, '\\\\$&');}, /** Un-escapes specified characters in specified string. @param {string} string @param {string} chars @returns {string} */ unescape: function (string, chars) {var unescapeRegexpLookup = $utils._unescapeRegexpLookup, re = unescapeRegexpLookup[chars];if (!re) {re = unescapeRegexpLookup[chars] = new RegExp('\\\\\\\\(\\\\\\\\|[' + chars + '])', 'g');}return string.replace(re, '$1');}, /** Splits string safely along the specified separator, leaving escaped separators unaffected. @param {string} string @param {string} separator @returns {string[]} */ safeSplit: function (string, separator) {var splitterRegexpLookup = $utils._splitterRegexpLookup, re = splitterRegexpLookup[separator], tokens, tokenCount, i, token, component, result = [];if (!re) {/* regexp leaves undefined 'holes' in token list where unescaped separators would be*/re = splitterRegexpLookup[separator] = new RegExp('(\\\\\\\\[' + separator + '])|[' + separator + ']');}/* joining tokens between holes*/tokens = string.split(re);tokenCount = tokens.length;for (i = 0, component = ''; i < tokenCount; i++) {token = tokens[i];if (token === undefined) {result.push(component);component = '';} else {component += token;}}result.push(component);return result;}, /** Converts a JSON object to a nested array with properties in alphabetical order. Mostly used as identifier when stringified. @param {Object} json @returns {Array|*} */ jsonToSafeJson: function (json) {if (json instanceof Array) {return ['array'].concat(json.map($utils.jsonToSafeJson));} else if (json instanceof Object) {return ['object'].concat(Object.keys(json).sort().map(function (key) {return [key, $utils.jsonToSafeJson(json[key])];}));} else {return json;}}, /** Converts a nested array back to its original form. Safe JSON is mostly used as identifier when stringified. @param {Array|*} safeJson @returns {Object|Array|*} */ safeJsonToJson: function (safeJson) {var nodeType;if (safeJson instanceof Array) {nodeType = safeJson.shift();switch (nodeType) {case 'array':return safeJson.map($utils.safeJsonToJson);case 'object':return safeJson.reduce(function (json, safeChildNode) {var key = safeChildNode[0], value = safeChildNode[1];json[key] = $utils.safeJsonToJson(value);return json;}, {});}} else {return safeJson;}}, /** Tests whether the specified string matches the specified prefix. @param {string} string @param {string} prefix @returns {boolean} */ matchesPrefix: function (string, prefix) {return string && string.substr(0, prefix.length) === prefix;}});\n"),
          "src/string/Stringifiable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Interface that represents any object, or class that implements a .toString() method. Instances of Stringifiable classes may be passed around like strings where they're expected alongside strings. @interface $utils.Stringifiable */ $utils.Stringifiable = $oop.createClass('$utils.Stringifiable').define(/** @lends $utils.Stringifiable# */{/** @returns {string} */ toString: function () {}}).build();\n"),
          "src/string/StringifyCached.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Caches the host class' instances by their stringified versions. Host must implement {@link $utils.Stringifiable}. @mixin $utils.StringifyCached */ $utils.StringifyCached = $oop.createClass('$utils.StringifyCached').cacheBy(function (properties) {return this.toString.call(properties);}).build();\n"),
          "src/class/Cloneable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Creates a new instance of identical class and state. @mixin $utils.Cloneable */ $utils.Cloneable = $oop.createClass('$utils.Cloneable').define(/** @lends $utils.Cloneable# */{/** Clones current instance. @returns {$utils.Cloneable} @todo Add \"recursive\" param? */ clone: function clone() {var Class = $oop.getClass(this.__classId);return Class.create(this);}}).build();\n"),
          "src/class/Destructible.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Adds a destroy method for final cleanup of instances. @interface $utils.Destructible */ $utils.Destructible = $oop.createClass('$utils.Destructible').define(/** @lends $utils.Destructible# */{/** @returns {$utils.Destructible} */ destroy: function () {}}).build();\n"),
          "src/class/Identifiable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Endows instances of the host class with a unique identifier. @mixin $utils.Identifiable */ $utils.Identifiable = $oop.createClass('$utils.Identifiable').define(/** @lends $utils.Identifiable# */{/** @memberOf $utils.Identifiable @type {number} */ lastInstanceId: -1, /** @ignore */ spread: function () {/** Identifies instance globally. @member {number} $utils.Identifiable#instanceId */ this.instanceId = this.instanceId || ++$utils.Identifiable.lastInstanceId;}}).build();\n"),
          "src/class/Retrievable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Keeps a registry of all living instances, and makes them accessible by their unique IDs. @mixin $utils.Retrievable @extends $utils.Identifiable @implements $utils.Destructible */ $utils.Retrievable = $oop.createClass('$utils.Retrievable').implement($utils.Destructible).blend($utils.Identifiable).define(/** @lends $utils.Retrievable# */{/** Global registry for instances having the Retrievable mixin. @memberOf $utils.Retrievable @type {object} */ instances: {}, /** @ignore */ init: function () {this._addToInstances();}, /** Adds instance to global registry. @returns {$utils.Retrievable} @private */ _addToInstances: function () {$utils.Retrievable.instances[this.instanceId] = this;return this;}, /** Removes instance from global registry. @returns {$utils.Retrievable} @private */ _removeFromInstances: function () {delete $utils.Retrievable.instances[this.instanceId];return this;}, /** @returns {$utils.Retrievable} */ destroy: function () {this._removeFromInstances();return this;}, /** Retrieves instance by its ID. @param {number|string} instanceId @returns {$utils.Retrievable} @memberOf $utils.Retrievable */ getInstanceById: function (instanceId) {return $utils.Retrievable.instances[instanceId];}}).build();\n"),
          "src/path/Path.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.Path.create @param {Object} properties @param {string[]} properties.components Identifiable 'steps' along the path. @returns {$utils.Path} *//** @class $utils.Path @mixes $utils.Cloneable @mixes $utils.Equatable @example $utils.Path.create(['foo', 'bar', 'baz']) */ $utils.Path = $oop.createClass('$utils.Path').blend($utils.Cloneable).blend($utils.Equatable).define(/** @lends $utils.Path# */{/** Path components. @member {Array.<string>} $utils.Path#components *//** Creates a `Path` instance based on the specified component array. @memberOf $utils.Path @param {Array.<string>} components @param {Object} [properties] @returns {$utils.Path} */ fromComponents: function (components, properties) {return this.create({components: components}, properties);}, /** @ignore */ init: function () {$assert.isArray(this.components, \"Invalid component list\");}, /** @inheritDoc @returns {$utils.Path} */ clone: function clone() {var cloned = clone.returned;cloned.components = this.components.concat();return cloned;}, /** Tests whether specified path is equivalent to current path. @param {$utils.Path} path @returns {boolean} */ equals: function equals(path) {var result = equals.returned;if (!result) {return result;}var componentsLeft = this.components, componentsRight = path.components, componentCount = componentsRight.length, i;if (componentsLeft.length !== componentsRight.length) {return false;} else {for (i = 0; i < componentCount; i++) {if (componentsLeft[i] !== componentsRight[i]) {return false;}}return result;}}}).build();\n"),
          "src/path/PathPattern.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.PathPattern.create @param {Object} [properties] @param {string[]} properties.components Series of patterns to match corresponding path components. @returns {$utils.PathPattern} *//** Path with colon-prefixed parameters. @class $utils.PathPattern @implements $utils.Matchable */ $utils.PathPattern = $oop.createClass('$utils.PathPattern').implement($utils.Matchable).define(/** @lends $utils.PathPattern# */{/** Query components. @member {Array.<$utils.PathPatternComponent>} $utils.PathPattern#components *//** Lookup of parameter indices by parameter name. @member {Object.<string,number>} $utils.PathPattern#_paramPositions @private *//** Creates a `PathPattern` instance based on the specified component array. @memberOf $utils.PathPattern @param {Array.<$utils.PathPatternComponent|string>} components @param {Object} [properties] @returns {$utils.PathPattern} */ fromComponents: function (components, properties) {return this.create({components: components}, properties);}, /** @ignore */ init: function () {$assert.isArray(this.components, \"Invalid component list\");var PatternComponent = $utils.PathPatternComponent;/* making sure all components are actually instances of $utils.PathPatternComponent*/this.components = this.components.map(function (component) {return PatternComponent.mixedBy(component) ? component : PatternComponent.fromString(component);});this._paramPositions = this.components.reduce(function (paramPositions, component, i) {var parameterName = component.parameterName;if (parameterName !== undefined) {paramPositions[parameterName] = i;}return paramPositions;}, {});}, /** Matches pattern against the specified `Path`. @param {$utils.Path} path @return {boolean} @todo Should return false for prefix match? */ matches: function (path) {var patternComponents = this.components, patternComponentCount = patternComponents.length, pathComponents = path.components, i, patternComponent, pathComponent;for (i = 0; i < patternComponentCount; i++) {patternComponent = patternComponents[i];pathComponent = pathComponents[i];if (!patternComponent.matches(pathComponent)) {return false;}}return true;}, /** Extracts value of the specified parameter from the specified `Path`. @param {$utils.Path} path @param {string} parameterName @returns {*} */ extractParameter: function (path, parameterName) {return path.components[this._paramPositions[parameterName]];}}).build();\n"),
          "src/path/PathPatternComponent.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.PathPatternComponent.create @param {Object} [properties] @returns {$utils.PathPatternComponent} *//** @class $utils.PathPatternComponent @extends $utils.Cloneable @implements $utils.Matchable @implements $utils.Stringifiable */ $utils.PathPatternComponent = $oop.createClass('$utils.PathPatternComponent').blend($utils.Cloneable).implement($utils.Matchable).implement($utils.Stringifiable).define(/** @lends $utils.PathPatternComponent# */{/** String representation of the component. @member {string} $utils.PathPatternComponent#componentString *//** Parameter name extracted from component. Undefined when no parameter can be extracted. @member {string} $utils.PathPatternComponent#parameterName *//** Creates a `PathPatternComponent` instance based on the specified string. @memberOf $utils.PathPatternComponent @param {string} componentString @param {Object} [properties] @returns {$utils.PathPatternComponent} */ fromString: function (componentString, properties) {return this.create({componentString: componentString}, properties);}, /** Creates a `QueryComponent` instance based on the specified string. @memberOf $utils.PathPatternComponent @param {string} parameterName @param {Object} [properties] @returns {$utils.PathPatternComponent} */ fromParameterName: function (parameterName, properties) {return this.create({parameterName: parameterName}, properties);}, /** @ignore */ spread: function () {if (this.componentString !== undefined) {this._spreadComponentString();}if (this.parameterName !== undefined) {this._spreadParameterName();}}, /** @private */ _spreadComponentString: function () {var componentString = this.componentString;if (componentString[0] === ':') {this.parameterName = $utils.unescapePathPatternComponent(componentString.substr(1));}}, /** @private */ _spreadParameterName: function () {this.componentString = ':' + $utils.escapePathPatternComponent(this.parameterName);}, /** @param {string} pathComponent @return {boolean} */ matches: function (pathComponent) {if (this.parameterName) {return true;} else {return this.componentString === pathComponent;}}, /** @returns {string} */ toString: function () {return this.componentString;}}).build();$oop.copyProperties($utils, /** @lends $utils */{/** Special characters in path pattern components. (To be escaped.) @constant */ PATH_PATTERN_COMPONENT_SPECIAL_CHARS: ':', /** @param {string} componentString @returns {string} */ escapePathPatternComponent: function (componentString) {return $utils.escape(componentString, $utils.PATH_PATTERN_COMPONENT_SPECIAL_CHARS);}, /** @param {string} componentString @returns {string} */ unescapePathPatternComponent: function (componentString) {return $utils.unescape(componentString, $utils.PATH_PATTERN_COMPONENT_SPECIAL_CHARS);}});\n"),
          "src/path/UriPath.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.UriPath.create @param {Object} [properties] @param {string[]} [properties.components] Identifiable 'steps' along the path. @returns {$utils.UriPath} *//** A `Path` representing the \"path\" component of a Universal Resource Identifier (URI). @class $utils.UriPath @extends $utils.Path @implements $utils.Stringifiable */ $utils.UriPath = $oop.createClass('$utils.UriPath').blend($utils.Path).implement($utils.Stringifiable).define(/** @lends $utils.UriPath# */{/** @memberOf $utils.UriPath @param {string} urlPath @param {Object} [properties] @returns {$utils.UriPath} */ fromString: function (urlPath, properties) {var components = urlPath.split($utils.URI_PATH_DELIMITER).map(decodeURIComponent);return this.create({components: components}, properties);}, /** @returns {string} */ toString: function () {return this.components.map(encodeURIComponent).join($utils.URI_PATH_DELIMITER);}}).build();$oop.copyProperties($utils, /** @lends $utils */{/** Separates UriPath components. @constant */ URI_PATH_DELIMITER: '/'});$oop.copyProperties(String.prototype, /** @lends String# */{/** @param {Object} [properties] @returns {$data.TreePath} */ toUriPath: function (properties) {return $utils.UriPath.fromString(this.valueOf(), properties);}});$oop.copyProperties(Array.prototype, /** @lends Array# */{/** @param {Object} [properties] @returns {$data.TreePath} */ toUriPath: function (properties) {return $utils.UriPath.create({components: this}, properties);}});\n"),
          "src/path/UriPathPattern.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.UriPathPattern.create @param {Object} [properties] @param {string[]} properties.components Series of patterns to match corresponding path components. @returns {$utils.UriPathPattern} *//** @class $utils.UriPathPattern @extends $utils.PathPattern @implements $utils.Stringifiable */ $utils.UriPathPattern = $oop.createClass('$utils.UriPathPattern').blend($utils.PathPattern).implement($utils.Stringifiable).define(/** @lends $utils.UriPathPattern# */{/** @memberOf $utils.UriPathPattern @param {string} uriPathPattern @param {Object} [properties] @returns {$utils.UriPathPattern} */ fromString: function (uriPathPattern, properties) {var components = $utils.safeSplit(uriPathPattern, $utils.URI_PATH_DELIMITER);return this.create({components: components}, properties);}, /** @returns {string} */ toString: function () {return this.components.map(String).map($utils.escapeUriPathDelimiter).join($utils.URI_PATH_DELIMITER);}}).build();$oop.copyProperties($utils, /** @lends $utils */{/** @param {string} uriPath @returns {string} */ escapeUriPathDelimiter: function (uriPath) {return $utils.escape(uriPath, $utils.URI_PATH_DELIMITER);}, /** @param {string} uriPath @returns {string} */ unescapeUriPathDelimiter: function (uriPath) {return $utils.unescape(uriPath, $utils.URI_PATH_DELIMITER);}});\n"),
          "src/async/async-utils.js": $buildUtils.Script.fromScriptBody("\"use strict\";$oop.copyProperties($utils, /** @lends $utils */{/** Sets up a timeout timer with the specified delay. Similar to window.setTimeout, except that instead of taking a callback the returned timer instance has a promise that is resolved when the timeout completes or is rejected when the timeout gets canceled. Resolution receives timer instance, plus original arguments except delay. Rejection receives arguments passed to {@link $utils.Timeout#clearTimer}. Doesn't get notifications. @param {number} delay @returns {$utils.Timeout} @see window.setTimeout */ setTimeout: function (delay) {var proxyArgs = [timeoutCallback].concat(slice.call(arguments)), timerId = setTimeout.apply(null, proxyArgs), timeout = $utils.Timeout.fromTimerId(timerId), deferred = timeout.timerDeferred;function timeoutCallback() {deferred.resolve.apply(deferred, arguments);}return timeout;}, /** Sets up an interval timer with the specified delay. Similar to window.setInterval, except that instead of taking a callback it returns a promise which is rejected when the interval timer is cleared, and is notified of each interval cycle. Progress receives interval instance, plus original arguments except delay. Rejection receives arguments passed to {@link $utils.Interval#clearTimer}. Never resolves. @param {number} delay @returns {$utils.Interval} @see window.setInterval */ setInterval: function (delay) {var proxyArgs = [intervalCallback].concat(slice.call(arguments)), timerId = setInterval.apply(null, proxyArgs), interval = $utils.Interval.fromTimerId(timerId), deferred = interval.timerDeferred;function intervalCallback() {deferred.notify.apply(deferred, arguments);}return interval;}});\n"),
          "src/async/schedule-utils.js": $buildUtils.Script.fromScriptBody("\"use strict\";$oop.copyProperties($utils, /** @lends $utils */{/** Debounces specified function with the specified delay. Passed function will be invoked when `delay` milliseconds have elapsed after the last call to the returned \"debounced\" function. The debounced function returns a Promise which gets notified whenever `originalFunction` is invoked, with its return value. @param {function} originalFunction @param {number} [delay=0] @returns {function} */ debounce: function (originalFunction, delay) {delay = delay || 0;var deferred = $utils.Deferred.create(), timer;function debounced() {/* (re-)starting timer*/if (timer) {timer.clearTimer();}timer = $utils.setTimeout(delay);/* updating last argument list and timer*/debounced.args = arguments;debounced.timer = timer;/* setting up timer to call `originalFunction` and notify returned promise*/timer.timerPromise.then(function () {/* invoking `originalFunction` and notifying returned promise*/deferred.notify(originalFunction.apply(null, debounced.args));}, function () {/* timer rejected by user, rejecting returned promise*/deferred.reject();});return deferred.promise;}return debounced;}, /** Throttles specified function with the specified delay. Passed function will be invoked once in every `delay` millisecond intervals where there was at least one call to the returned \"throttled\" function. The throttled function returns a Promise which gets notified whenever `originalFunction` is invoked, with its return value. On multiple calls to the throttled function within a single interval, arguments of the last one will be passed to `originalFunction`. @param {function} originalFunction @param {number} delay @returns {function} */ throttle: function (originalFunction, delay) {delay = delay || 0;var deferred = $utils.Deferred.create(), callCount = 0, timer = $utils.setInterval(delay);function throttled() {/* updating last arguments*/throttled.args = arguments;/* increasing call count within interval*/callCount++;return deferred.promise;}/* storing timer on throttled function*/throttled.timer = timer;/* setting up timer to call `originalFunction` and notify returned promise*/timer.timerPromise.then(null, function () {/* timer rejected by user, rejecting returned promise*/deferred.reject();}, function () {if (callCount > 0) {/* invoking `originalFunction` and notifying returned promise*/deferred.notify(originalFunction.apply(null, throttled.args));/* interval over, resetting call count*/callCount = 0;}});return throttled;}});"),
          "src/async/Timer.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.Timer.create @param {Object} properties] @param {number} properties.timerId @returns {$utils.Timer} *//** Manages state for timed function calls. @class $utils.Timer @todo Check in Node.js */ $utils.Timer = $oop.createClass('$utils.Timer').define(/** @lends $utils.Timer# */{/** ID associated with timer. @member {number} $utils.Timer#timerId *//** Allows external control of the timer. @member {$utils.Deferred} $utils.Timer#timerDeferred @see $utils.Timer#clearTimer *//** Resolves when the timer completes as planned. Rejects when the timer gets interrupted. @member {$utils.Promise} $utils.Timer#timerPromise *//** @memberOf $utils.Timer @param {number} timerId @param {Object} [properties] @returns {$utils.Timer} */ fromTimerId: function (timerId, properties) {return this.create({timerId: timerId}, properties);}, /** @ignore */ init: function () {$assert.isDefined(this.timerId, \"Invalid timer ID\");var timerDeferred = $utils.Deferred.create(), timerPromise = timerDeferred.promise;this.timerDeferred = timerDeferred;this.timerPromise = timerPromise;this.elevateMethods('onTimerPromiseResolve', 'onTimerPromiseReject');timerPromise.then(this.onTimerPromiseResolve, this.onTimerPromiseReject);}, /** Stops the timer. Clearing an already cleared interval timer will have no effect. @returns {$utils.Timer} */ clearTimer: function () {var timerDeferred = this.timerDeferred;timerDeferred.reject.apply(timerDeferred, arguments);return this;}, /** @ignore */ onTimerPromiseResolve: function () {this.clearTimer();}, /** @ignore */ onTimerPromiseReject: function () {this.clearTimer();}}).build();\n"),
          "src/async/Timeout.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.Timeout.create @param {Object} properties @param {number} properties.timerId @returns {$utils.Timeout} *//** Represents a timeout ID with promise capabilities. Allows to cancel a timeout via window.clearTimeout. @class $utils.Timeout @extends $utils.Timer */ $utils.Timeout = $oop.createClass('$utils.Timeout').blend($utils.Timer).define(/** @lends $utils.Timeout# */{/** @inheritDoc @returns {$utils.Timeout} */ clearTimer: function () {clearTimeout(this.timerId);return this;}}).build();/** @external Number */ $oop.copyProperties(Number.prototype, /** @lends Number# */{/** Converts `Number` to `Timeout` instance. @param {Object} [properties] @returns {$utils.Timeout} */ toTimeout: function (properties) {return $utils.Timeout.create({timerId: this.valueOf()}, properties);}});\n"),
          "src/async/Interval.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.Interval.create @param {Object} properties @param {number} properties.timerId @returns {$utils.Interval} *//** Represents an interval ID with promise capabilities. Allows to cancel an interval timer via `window.clearInterval`. @class $utils.Interval @extends $utils.Timer */ $utils.Interval = $oop.createClass('$utils.Interval').blend($utils.Timer).define(/** @lends $utils.Interval# */{/** @inheritDoc @returns {$utils.Interval} */ clearTimer: function () {clearInterval(this.timerId);return this;}}).build();/** @external Number */ $oop.copyProperties(Number.prototype, /** @lends Number# */{/** Converts `Number` to `Interval` instance. @param {Object} [properties] @returns {$utils.Interval} */ toInterval: function (properties) {return $utils.Interval.create({timerId: this.valueOf()}, properties);}});\n"),
          "src/promise/Thenable.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Basis for promises. Allows baseline documentation-level compatibility with promises from external libraries. (Eg. Q, jQuery, ES6, etc.) @interface $utils.Thenable */ $utils.Thenable = $oop.createClass('$utils.Thenable').define(/** @lends $utils.Thenable# */{/** Assigns event handlers to the `Promise`, to be called on resolution, rejection, or notification of the corresponding `Deferred`. @param {function} successHandler @param {function} failureHandler @param {function} progressHandler @returns {$utils.Thenable} */ then: function (successHandler, failureHandler, progressHandler) {}}).build();$oop.copyProperties($assert, /** @lends $assert */{/** @param {object} expr @param {string} [message] @returns {$assert} */ isThenable: function (expr, message) {return $assert.assert(expr instanceof Object && typeof expr.then === 'function', message);}, /** @param {object} [expr] @param {string} [message] @returns {$assert} */ isThenableOptional: function (expr, message) {return $assert.assert(expr === undefined || expr instanceof Object && typeof expr.then === 'function', message);}});\n"),
          "src/promise/Deferred.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** @function $utils.Deferred.create @returns {$utils.Deferred} *//** Q-style deferred controlling the corresponding Promises/A implementation. @see $utils.Promise @class $utils.Deferred */ $utils.Deferred = $oop.createClass('$utils.Deferred').define(/** @lends $utils.Deferred# */{/** @ignore */ init: function () {/** Promise associated  with `Deferred`. Provides access to \"resolve\", \"reject\", and \"progress\" events. @member {$utils.Promise} $utils.Deferred#promise */ this.promise = $utils.Promise.create();}, /** Resolves promise, invoking success handlers associated with `promise`. @returns {$utils.Deferred} */ resolve: function () {var deferredArguments = arguments, promise = this.promise;if (promise.promiseState === $utils.PROMISE_STATE_PENDING) {/* setting state*/promise.promiseState = $utils.PROMISE_STATE_FULFILLED;/* storing arguments*/promise.deferredArguments = deferredArguments;/* calling success handlers*/promise.successHandlers.forEach(function (handler) {handler.apply(promise, deferredArguments);});}return this;}, /** Rejects promise, invoking failure handlers associated with `promise`. @returns {$utils.Deferred} */ reject: function () {var deferredArguments = arguments, promise = this.promise;if (promise.promiseState === $utils.PROMISE_STATE_PENDING) {/* setting state*/promise.promiseState = $utils.PROMISE_STATE_REJECTED;/* storing arguments*/promise.deferredArguments = deferredArguments;/* calling failure handlers*/promise.failureHandlers.forEach(function (handler) {handler.apply(promise, deferredArguments);});}return this;}, /** Notifies promise of progress, invoking progress handlers associated with `promise`. @returns {$utils.Deferred} */ notify: function () {var args = arguments, promise = this.promise;if (promise.promiseState === $utils.PROMISE_STATE_PENDING) {/* storing arguments*/promise.notificationArguments.push(args);/* calling progress handlers*/promise.progressHandlers.forEach(function (handler) {handler.apply(promise, args);});}return this;}}).build();\n"),
          "src/promise/Promise.js": $buildUtils.Script.fromScriptBody("\"use strict\";/** Not to be used by other than $utils.Deferred @memberOf $utils~ @function $utils.Promise.create @returns {$utils.Promise} @ignore *//** Non-interactive synchronous implementation of Promises/A. @see http://wiki.commonjs.org/wiki/Promises/A @see $utils.Deferred @class $utils.Promise @implements $utils.Thenable */ $utils.Promise = $oop.createClass('$utils.Promise').implement($utils.Thenable).define(/** @lends $utils.Promise# */{/** Current state of the promise. Possible values: \"pending\", \"fulfilled\", or \"rejected\". @member {string} $utils.Promise#promiseState *//** Argument list passed to the `resolve` or `reject` of the corresponding `Deferred`. @member {Array} $utils.Promise#deferredArguments *//** Argument list passed to the `notify` of the corresponding `Deferred`. @member {Arguments[]} $utils.Promise#notificationArguments *//** List of callbacks to be invoked on resolution. @member {function[]} $utils.Promise#successHandlers *//** List of callbacks to be invoked on rejection. @member {function[]} $utils.Promise#failureHandlers *//** List of callbacks to be invoked on notification. @member {function[]} $utils.Promise#progressHandlers *//** @ignore */ init: function () {this.promiseState = $utils.PROMISE_STATE_PENDING;this.notificationArguments = [];this.successHandlers = [];this.failureHandlers = [];this.progressHandlers = [];}, /** Assigns event handlers to the `Promise`, to be called on resolution, rejection, or notification of the corresponding `Deferred`. @param {function} [successHandler] @param {function} [failureHandler] @param {function} [progressHandler] @returns {$utils.Promise} */ then: function (successHandler, failureHandler, progressHandler) {if (successHandler) {switch (this.promiseState) {case $utils.PROMISE_STATE_FULFILLED:successHandler.apply(this, this.deferredArguments);break;case $utils.PROMISE_STATE_PENDING:this.successHandlers.push(successHandler);break;}}if (failureHandler) {switch (this.promiseState) {case $utils.PROMISE_STATE_REJECTED:failureHandler.apply(this, this.deferredArguments);break;case $utils.PROMISE_STATE_PENDING:this.failureHandlers.push(failureHandler);break;}}if (progressHandler) {if (this.promiseState === $utils.PROMISE_STATE_PENDING) {/* adding progress handler to list of handlers*/this.progressHandlers.push(progressHandler);/* passing previous notifications to new handler*/this.notificationArguments.forEach(function (args) {progressHandler.apply(this, args);});}}return this;}, /** Returns a promise that is fulfilled when all passed promises are fulfilled, or fails when one of them fails. Invokes progress on each promise' progress, and when individual promises are fulfilled. The order of invoking the returned promise and the original promises' handlers is not deterministic. @param {$utils.Promise[]} promises A list of promises. Non-promises will be treated as resolved promises. @returns {$utils.Promise} @memberOf $utils.Promise */ when: function (promises) {var deferred = $utils.Deferred.create(), promiseCount = promises.length, deferredArguments = [];function tryResolving() {deferredArguments.push(arguments);if (--promiseCount === 0) {/* resolving last promise with aggregate*/deferred.resolve(deferredArguments);} else {/* notifying aggregate promise of fulfilment*/deferred.notify.apply(deferred, arguments);}}if (promiseCount) {promises.forEach(function (promise) {if (promise && typeof promise.then === 'function') {/* latching on to next promise in array*/promise.then(tryResolving, deferred.reject.bind(deferred));} else {/* passing non-promise to resolution*/tryResolving(promise);}});} else {deferred.resolve();}return deferred.promise;}}).build();$oop.copyProperties($utils, /** @lends $utils */{/** @constant */ PROMISE_STATE_PENDING: 'pending', /** @constant */ PROMISE_STATE_FULFILLED: 'fulfilled', /** @constant */ PROMISE_STATE_REJECTED: 'rejected'});\n"),
          //@formatter:on
        });
      });

      it("should resolve script order", function () {
        var result = scriptCollection.getDependencyOrder(extractor);
        expect(result).toEqual([
          "src/class/Destructible.js",
          "src/class/Identifiable.js",
          "src/class/Cloneable.js",
          "src/utils/Equatable.js",
          "src/utils/Matchable.js",
          "src/string/Stringifiable.js",
          "src/async/Timer.js",
          "src/promise/Thenable.js",
          "src/path/Path.js",
          "src/path/PathPattern.js",
          "src/class/Retrievable.js",
          "src/path/PathPatternComponent.js",
          "src/async/Timeout.js",
          "src/async/Interval.js",
          "src/promise/Promise.js",
          "src/path/UriPath.js",
          "src/path/UriPathPattern.js"
        ]);
      });
    });
  });
});
